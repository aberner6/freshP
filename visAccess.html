<html>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery
/1.3.2/jquery.min.js"></script>
<script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="underscore-min.js"></script>
<script type = "text/javascript" src = "http://pelars
.sssup.it:8080/pelars/auth.js"></script>
<body>
<script type="text/javascript">
var data;
var types = ["hand","ide","particle","face"];
var handData = [];

var cwidth=200,cheight=200,cmargin=25,maxr=5;

var nested_data;
var m = [15, 20, 40, 120], //top right bottom left
    w = window.innerWidth-cmargin,
    h = window.innerHeight;
var goAhead;
var svg = d3.select("body").append("svg").attr("width",w).attr("height",h);

var nest_again;
var ideData;

var ide_nest;
var open = [];
var close = [];


var timeMin, timeMax;
var timeX = d3.scale.linear();
var maxtime = [];
var whatTime = [];	

$(document).ready(function() {
	var  token = pelars_authenticate();
	$.getJSON("http://pelars.sssup.it:8080/pelars/data/615/session?token="+token ,function(json){
// if(token){
	// $.getJSON( "http://pelars.sssup.it:8080/pelars/data/615/session?token="+token,function(json) { 
		// document.getElementById("id").innerHTML = JSON.stringify(json); 
		data = (json);

		nested_data = d3.nest()
			.key(function(d) { return d.type; })
			.key(function(d){ return d.num; })
			.entries(data);

		nested_face = d3.nest()
			.key(function(d) { return d.type; })
			.entries(data);

		nest_again = d3.nest()
			.key(function(d) { return d.type; })
			.key(function(d){ return d.num; })
			.rollup(function(leaves) { 
				return { 
						"max_time": d3.max(leaves, function(d) {
							return parseFloat(d.time);
						}),
						"min_time": d3.min(leaves, function(d) {
							return parseFloat(d.time);
						})
					} 
				})
			.entries(data)

		if (typeof nested_data !== "undefined"){
			for(i=0; i<nested_data.length; i++){
				if(nested_data[i].key&&nest_again[i].key==types[0]){
					console.log(nested_data[i].key)
					goHands(nested_data[i], nest_again[i].values);
				}
				if(nested_face[i].key&&nest_again[i].key==types[3]){
					console.log(nested_face[i].key)
					goFace(nested_face[i], nest_again[i].values);
				}
				if(nested_data[i].key&&nest_again[i].key=="ide"){
					console.log(nested_data[i].key)
					goIDE(nested_data[i].values, nest_again[i].values);
				}
				compress();
				// else{ console.log("nope")}
			}	
		}
	});


// var token = "tjoKrRSRFdq8Aw5I-_i7uvBjdCBbiNzHBMeaGl3k0UH4KE7zwzYSeogzqHg1-EQvIUH5Gdtx7Uc3IdMb30uR5AJYUS_yan4pHh1pFcQX2s7KGdnvSpCm9QJ91Ndsk4Ry";
// var token;
	// pelars_authenticate();

function pelars_authenticate(){
	var email = "d.paiva@ciid.dk";
	var pswd = "pelars123!";
	var jsres;
	var res = "";
	jQuery.ajax({
		timeout : 1000,
		type : "POST",
		url : "http://pelars.sssup.it:8080/pelars/password?user=" + email + "&pwd=" + pswd,
		async: false,
		success : function(jqXHR, status, result){
		jsres = JSON.parse(jqXHR);
		res = jsres["token"];
		},
		error : function(jqXHR, status) {
			res = 0; }
	});
	//document.getElementById("tag").innerHTML = res;
	return res;
}


var minRX, maxRX, minRY, maxRY, minFX, minFY, maxFX, maxFY;
var rx = [];
var ry = [];
var xIs = [];
var yIs = [];

var toggling = true;

var x=d3.scale.linear().range([cmargin,cwidth-cmargin]);
var y=d3.scale.linear().range([cheight-cmargin,cmargin]);
var o=d3.scale.linear().domain([0,300000]).range([.5,1]);

var fx=d3.scale.linear().range([cmargin,cwidth-cmargin]);
var fy=d3.scale.linear().range([cheight-cmargin,cmargin]);

var rows = 2;

var radSize = 3;
//probably have to fix this
svg.on("click", function(){
	toggling = !toggling;
	console.log(toggling)
	if(!toggling){
		d3.selectAll(".hand")
			.transition()
			.attr("transform",function(d,i) {
		  		return "translate("+cmargin+",0)";
		  	});
		// d3.selectAll(".face")
		// 	.transition()
		// 	.attr("transform",function(d,i) {
		//   		return "translate("+cmargin+",0)";
		//   	});
		$(".rectText").hide();
		$(".faceText").hide();
	}
	if(toggling){
		d3.selectAll(".hand")
			.transition()
			.attr("transform",function(d,i) {
		  		return "translate("+cwidth*i+",0)";
		  	});
		// d3.selectAll(".face")
		// 	.transition()
		// 	.attr("transform",function(d,i) {
	 //  		return "translate("+(cwidth*i)+","+(cheight*rows)+")";
		//   	});
		$(".rectText").show();
		$(".faceText").show();
	}
})

function goIDE(incomingD, summary){
	ideData = incomingD[0].values;
	sumIDE = summary;
	console.log("in IDE");
    var patt1 = /[A-Z]/gi; 
	// console.log(ideData);
	for(i=0; i<ideData.length; i++){
		ideData[i].name= ideData[i].opt.match(patt1).join().replace(/,/g, '');
		if(ideData[i].action_id.length>2){
			ideData[i].mod = ideData[i].action_id.substr(0, 2);
			ideData[i].oc = ideData[i].action_id.substr(2, 2);
		}else{ //doesn't matter about the CC without open close
			ideData[i].mod = ideData[i].action_id.substr(0, 1);
			ideData[i].oc = ideData[i].action_id.substr(1, 1);
		}
		ideData[i].special_id = ideData[i].mod+ideData[i].opt;
	}
	ide_nest = d3.nest()
		.key(function(d) { 
			return d.time; 
		})
		.sortKeys(d3.ascending)
		// .key(function(d) { 
		// 	return d.data_id; 
		// })		
		// .key(function(d) { 
		// 	return d.mod; 
		// })
		.entries(ideData)

	var g = svg.selectAll(".ide")
	// var g = nextSesh.selectAll(".ide")
		.data(ide_nest)
		.enter()
	  	.append("g")
	  	.attr("class","ide");
		// now marks, initiated to default values
		g.selectAll("rect")
		// we are getting the values of the countries like this:
		.data(function(d) {
			return d.values;
		}) 
		.enter()
		.append("rect")
		.attr("x", function(d){
			return timeX(d.time)
		})
		.attr("y", function(d){
			return h-100;
		})
		.attr("width",function(d,i){
			// console.lo g(d.special_id+"  "+d.oc)
			if(parseInt(d.oc)==1){
				open.push(d);
			}
			for(j=0; j<open.length; j++){
				if(d.oc==2&&d.special_id==open[j].special_id){
					console.log(d.special_id+" "+open[j].special_id)
				}
			}

			// if(parseInt(d.oc)==1){
			// 	open.push(d);
			// } 
			// else {
			// 	close.push(d);
			// }
			// for (var j=0; j<open.length; j++){
			// 	for (var k=0; k<close.length; k++){
			// 		if(open[j].special_id===close[k].special_id){
			// 			console.log(open[j].special_id)
			// 		}else{}				
			// 	}
			// }

			// speci.push(d.special_id);
		 	// matches = _.findWhere(speci, "M12 POT");
return 5;
		})
		.attr("height",5)
		// .attr("r", 5)
		.attr("fill", function(d){
			if(d.oc==1){
				return "green";
			}else{
				return "red";
			}
		})
		.attr("opacity",.3)
}
var miniTime = [];
function goFace(incomingData, summary){
	var toD = incomingData;
	console.log(toD)
	var summary = summary;
	console.log(summary);
	for(j=0; j<summary.length; j++){
		miniTime.push(summary[j].values.min_time)
		whatTime.push(summary[j].values.max_time)
	}
	timeMin = d3.min(miniTime);
	timeMax = d3.max(whatTime);
	timeX.domain([timeMin, timeMax]).range([cmargin, w-cwidth+cmargin]);
	// One cell for each face tracked (hands are in nested data @ at 1)
	var g = svg.selectAll(".face")
		.data(toD.values)
		.enter()
	  	.append("circle")
	  	.attr("class","face")
		    .attr("cx",function(d) {
			  	return timeX(d.time) //cmargin)
			})
		    	// return fx(d['distance from camera']);;
		    // })
		    .attr("cy",function(d) {
			  	return h/2-d.num*10;
		    	// return fy(d['distance from camera']);;
		    })
		    .attr("fill","blue")
		    .attr("opacity",.5)
		    .attr("r",radSize)
	  	// .attr("transform",function(d,i) {
	  	// 	if(d.key==summary[i].key){
		  // 		return "translate("+(timeX(whatTime[i]))+","+(cheight*rows)+")";
		  // 		// return "translate("+(cwidth*i)+","+(cheight*rows)+")";
	  	// 	}
	  	// });
		// g
		//   .append("rect")
		//   // .attr("class","faceBox")
		//   .attr("x",cmargin)
		//   .attr("y",cmargin)
		//   .attr("width",cwidth)//-2*cmargin)
		//   .attr("height",cheight)//-2*cmargin)
		//   .attr("fill","none")
		//   .attr("stroke","lightgray");
		// we also write its name below.
		// g
		//   .append("text")
		//   .attr("class","faceText")
		//   .attr("y",cheight+10)
		//   .attr("x",cmargin)
		//   .text(function(d,i) {
	 //  		if(d.key==summary[i].key){
	 //  			// return (summary[i].values.max_time);
	 //  		}
		//   	// return d.values.length+" "+d.key;
		//   })
		
		// now marks, initiated to default values
		// g.selectAll(".faceCircle")
		// we are getting the values of the countries like this:
		// .data(function(d) {
			// return d;
		// }) 
		// .enter()
		//   .append("circle")
		//   .attr("class","faceCircle")
		//   .attr("cx", cmargin)
		//   .attr("cy", h/2)//cheight-cmargin)
		//   .attr("fill","pink")
		//   // .attr("stroke","pink")
		//   .attr("r",5)
		    // throwing in a title element
		  //   .append("title")
		  //     .text(function(d) {
		  //     	xIs.push(d['distance from camera']);
				// minFX = d3.min(xIs);
				// maxFX = d3.max(xIs);
		      	
		  //     	yIs.push(d['distance from camera']);
				// minFY = d3.min(yIs);
				// maxFY = d3.max(yIs);

				// fy.domain([minFY, maxFY])
				// fx.domain([minFX, maxFX])
		  //     	return d.num;
		  //     });
		 
		// finally, we animate our marks in position
		// g.selectAll("circle").transition().delay(100)
		// .duration(1000)
		//     .attr("r",1)
		//     .attr("cx",function(d) {
		// 	  	return timeX(d.time) //cmargin)
		// 	})
		//     	// return fx(d['distance from camera']);;
		//     // })
		//     .attr("cy",function(d) {
		// 	  	return h/2+d.num*10;
		//     	// return fy(d['distance from camera']);;
		//     })
}
function goHands(incomingData, summary){	
	console.log(summary)
	var toD = incomingData;
	var summary = summary;
	// One cell for each hand tracked (hands are in nested data @ at 1)
	var g = svg.selectAll(".hand")
		.data(toD.values)
		.enter()
	  	.append("g")
	  	.attr("class","hand")
	  	.attr("transform",function(d,i) {
	  		return "translate("+(cwidth*i)+",0)";
	  	});

		g
		  .append("rect")
		  .attr("x",cmargin)
		  .attr("y",cmargin)
		  .attr("width",cwidth)//-2*cmargin)
		  .attr("height",cheight)//-2*cmargin)
		  .attr("fill","none")
		  .attr("stroke","lightgray");
		// we also write its name below.
		g
		  .append("text")
		  .attr("class","rectText")
		  .attr("y",cheight+10)
		  .attr("x",cmargin)
		  .text(function(d,i) {
	  		if(d.key==summary[i].key){
	  			// return (summary[i].values.max_time);
	  		}
		  })
		
		// now marks, initiated to default values
		g.selectAll("circle")
		// we are getting the values of the countries like this:
		.data(function(d) {
			return d.values;
		}) 
		.enter()
		  .append("circle")
		  .attr("cx",cmargin)
		  .attr("cy",cheight-cmargin)
		  .attr("fill","none")
		  .attr("stroke","grey")
		  .attr("r",1)
		    // throwing in a title element
		    .append("title")
		      .text(function(d) {
		      	rx.push(d.rx);
				minRX = d3.min(rx);
				maxRX = d3.max(rx);
		      	
		      	ry.push(d.ry);
				minRY = d3.min(ry);
				maxRY = d3.max(ry);

				y.domain([minRY, maxRY])
				x.domain([minRX, maxRX])
		      	// console.log(minRX);
		      	// return d.num;
		      });
		 
		// finally, we animate our marks in position
		g.selectAll("circle").transition().delay(100).duration(1000)
		    .attr("r",radSize)
		    .attr("cx",function(d) {
		    	return x(d.rx);
		    })
		    .attr("cy",function(d) {
		    	return y(d.ry);
		    })
}


function compress(){
	d3.selectAll(".hand")
		.transition().delay(1000).duration(2000)
		.attr("transform",function(d,i) {
	  		return "translate("+cmargin+",0)";
	  	});
	// d3.selectAll(".face")
	// 	.transition().delay(1000).duration(2000)
	// 	.attr("transform",function(d,i) {
	//   		return "translate("+cmargin+",0)";
	//   	});
	$(".rectText").hide();
	$(".faceText").hide();
}
// }
})
</script>
</body>
</html>